#!/bin/sh
# ========================================================
# nodeconductor-celeryd - Starts the Celery worker daemon.
# ========================================================
#
# :Usage: /etc/init.d/nodeconductor-celeryd {start|stop|restart|status}
# :Configuration file: /etc/sysconfig/nodeconductor-celeryd
#
# See http://docs.celeryproject.org/en/latest/tutorials/daemonizing.html

### BEGIN INIT INFO
# Provides:          nodeconductor-celeryd
# Required-Start:    $network $local_fs $remote_fs
# Required-Stop:     $network $local_fs $remote_fs
# Default-Start:     2 3 4 5
# Default-Stop:      0 1 6
# Short-Description: celery task worker daemon
### END INIT INFO

#
# Defaults
#

DEFAULT_LOG_FILE="/var/log/nodeconductor/celeryd-%n.log"
DEFAULT_LOG_LEVEL="INFO"
DEFAULT_NODES="node1"

# some commands work asyncronously, so we'll wait this many seconds
SLEEP_SECONDS=5

#
# Functions
#

check_dev_null() {
    if [ ! -c /dev/null ]; then
        echo "/dev/null is not a character device!"
        exit 75  # EX_TEMPFAIL
    fi
}

check_status() {
    local pid_files=$(_get_pid_files)
    [ -z "$pid_files" ] && echo "$prog is stopped" && return 1
    for pid_file in $pid_files; do
        local node=$(basename "$pid_file" .pid)
        status -p "$pid_file" $"$prog (node $node)" || return 1  # if one node is down celeryd is down
    done
    return 0
}

maybe_die() {
    if [ $? -ne 0 ]; then
        echo "Exiting: $* (errno $?)"
        exit 77  # EX_NOPERM
    fi
}

start() {
    echo -n $"Starting $prog: "

    # If Celery is already running, bail out
    local pid_files=$(_get_pid_files)
    if [ ! -z "$pid_files" ]; then
        echo -n $"$prog is already running. Use 'restart'."
        failure
        echo
        return 1
    fi

    DEBUG_CMD="celery worker --logfile='$CELERYD_LOG_FILE' --loglevel='$CELERYD_LOG_LEVEL' --pidfile='$CELERYD_PID_FILE' $CELERYD_OPTS"
    DEBUG_MSG="Failed to start Celery daemon.\nTry running this command as user '$CELERYD_USER' to check what went wrong:\n\n  $DEBUG_CMD\n"

    celery multi start \
        $CELERYD_NODES \
        $DAEMON_OPTS \
        --cmd="-m celery.bin.celeryd_detach" \
        --logfile="$CELERYD_LOG_FILE" \
        --loglevel="$CELERYD_LOG_LEVEL" \
        --pidfile="$CELERYD_PID_FILE" \
        --quiet \
        $CELERYD_OPTS
    if [ $? -ne 0 ]; then
        failure
        echo
        echo -e $DEBUG_MSG
        return 1
    fi

    # Sleep a few seconds to give Celery a chance to initialize itself.
    # This is useful to prevent scripts following this one from trying to
    # use Celery (or its pid files) too early.
    sleep $SLEEP_SECONDS

    pid_files=$(_get_pid_files)
    if [ -z "$pid_files" ]; then
        failure
        echo
        echo -e $DEBUG_MSG
        return 1
    fi

    for pid_file in $pid_files; do
        local node=$(basename "$pid_file" .pid)
        local pid=$(cat "$pid_file")
        echo
        echo -n "    $node (pid $pid):"
        success
    done
    echo
    return 0
}

stop() {
    local pid_files=$(_get_pid_files)
    [ -z "$pid_files" ] && echo "$prog is stopped" && return 0

    local one_failed=
    for pid_file in $pid_files; do
        local pid=$(cat "$pid_file")
        echo -n $"Stopping $prog (pid $pid): "

        # killproc comes from 'functions' and brings three nice features:
        #  1. sending TERM, sleeping, then sleeping more if needed, then sending KILL
        #  2. handling 'success' and 'failure' output
        #  3. removes stale pid files, if any remain
        killproc -p "$pid_file" -d "$SLEEP_SECONDS" $prog || one_failed=true
        echo
    done

    [[ "$one_failed" ]] && return 1 || return 0
}

_get_pid_files() {
    [[ ! -d "$CELERYD_PID_DIR" ]] && return
    echo $(ls -1 "$CELERYD_PID_DIR"/*.pid 2> /dev/null)
}

#
# Main flow
#

# If we're invoked via SysV-style runlevel scripts we need to follow the 
# link from rcX.d before working out the script name.
if [[ `dirname $0` == /etc/rc*.d ]]; then
    target="$(readlink $0)"
else
    target=$0
fi
prog="$(basename $target)"

# Source the centos service helper functions
# NOTE: "set -e" does not work with these functions,
# which use non-zero return codes as non-error return conditions
. /etc/init.d/functions

CELERY_DEFAULTS="/etc/sysconfig/$prog"
[ -f "$CELERY_DEFAULTS" ] && . "$CELERY_DEFAULTS"

CELERYD_LOG_FILE=${CELERYD_LOG_FILE:-$DEFAULT_LOG_FILE}
CELERYD_LOG_LEVEL=${CELERYD_LOG_LEVEL:-$DEFAULT_LOG_LEVEL}
CELERYD_NODES=${CELERYD_NODES:-$DEFAULT_NODES}
CELERYD_PID_FILE="/var/run/$prog/%n.pid"

CELERYD_LOG_DIR=$(dirname $CELERYD_LOG_FILE)
CELERYD_PID_DIR=$(dirname $CELERYD_PID_FILE)

# Extra start-stop-daemon options, like user/group.
[ -n "$CELERYD_USER" ] && DAEMON_OPTS="$DAEMON_OPTS --uid=$CELERYD_USER"
[ -n "$CELERYD_GROUP" ] && DAEMON_OPTS="$DAEMON_OPTS --gid=$CELERYD_GROUP"
[ -n "$CELERYD_CHDIR" ] && DAEMON_OPTS="$DAEMON_OPTS --workdir=$CELERYD_CHDIR"

# This is used to change how Celery loads in the configs.
# It does not need to be set to be run.
export CELERY_LOADER
export PATH="${PATH:+$PATH:}/usr/sbin:/sbin"

case "$1" in
    start)
        check_dev_null
###        check_paths
        start
    ;;

    stop)
        check_dev_null
###        check_paths
        stop
    ;;

    status)
        check_status
    ;;

    restart)
        check_dev_null
###        check_paths
        stop && start
    ;;

    *)
        echo "Usage: /etc/init.d/$prog {start|stop|restart|status}"
        exit 3
    ;;
esac

exit $?
